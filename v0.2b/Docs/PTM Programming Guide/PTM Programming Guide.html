<html>
<head>
    <link rel="stylesheet" href="style.css">
</head>

<div class="main-title">
    <h1>PTM - Programmable Tile Machine</h1>
    <h2>Programming Guide ( v0.2b )</h2>
</div>

<div class="content">

<div class="section" id="links">
    <div class="section-title">Links</div>
    <p>
        Project source code on GitHub: <a href="https://github.com/FernandoAiresCastello/PTM" target="_blank">https://github.com/FernandoAiresCastello/PTM</a>
        <br>
        Release page on Itch.io: <a href="https://fernandoairescastello.itch.io/ptm" target="_blank">https://fernandoairescastello.itch.io/ptm</a>
    </p>
</div>

<div class="section" id="about">
    <div class="section-title">About</div>
    <p>PTM (Programmable Tile Machine) is a "pseudo-8-bit fantasy computer" that you can program using a built-in programming language called PTML. The system aims to be similar in look-and-feel to some early 8-bit computer systems such as the MSX, ZX Spectrum and Atari 800. Also inspired by the modern game engines Bitsy and PICO-8.</p>
    <p>PTML is an interpreted, imperative, semi-structured, loosely typed, low-level programming language, with only two data types: strings and integers (with support for dynamic arrays of those types). All you need for programming in it is a plain-text editor like Notepad. The syntax looks like some early dialects of BASIC and some common Assembly languages for 8-bit computers. Familiarity with any of those will probably make it easier to work with PTML, but the language itself is fairly straightforward.</p>
</div> <!-- end section -->

<div class="section" id="how-to-run-programs">
    <div class="section-title">How To Run Programs</div>
    <p>The PTM.exe file is the machine executable, which also contains the PTML interpreter. To run any PTML program, you need to provide the PTML source code file to PTM.exe. PTML source code files are plain-text files that end with the extension .ptm. There are two ways to run a program:</p>
    <ol>
        <li>You can either drag and drop the *.ptm file onto the PTM.exe file.</li>
        <li>Or you can pass the path to a *.ptm file to the PTM.exe file via the command line. The path of the *.ptm file needs to be relative to the location of the PTM.exe file.</li>
    </ol>
</div> <!-- end section -->

<div class="section" id="the-main-ptm-file">
    <div class="section-title">The main.ptm File</div>
    <p>If you simply double-click PTM.exe without specifying the path of any PTML program file, it will look for a “main.ptm” file in the same directory and run it. If it doesn't find one, an error will appear. A default main.ptm file is usually included in the release package.</p>
    <p>As of version 0.2b, the default main.ptm file includes an utility program called “PTM Launcher” that shows an interactive menu where you can browse and launch an existing program without having to manually provide the .ptm file to the machine executable.</p>
</div> <!-- end section -->

<div class="section" id="hello-world">
    <div class="section-title">Hello World!</div>
    <p>Let's start with the most basic program ever, as we usually do when we begin learning any new programming language. PTML is partially inspired by BASIC language dialects for early 8-bit computers. As such, the “Hello World” program in PTML is a very simple one-liner:</p>
    <div class="code">
    PRINT “Hello World!”
    </div>
    <p>When this code is executed, the machine will print the text "Hello World!" (without the quotes) on the window. The double quotes around the text are required since it's a literal string (as opposed to a variable or a number). The position and colors in this example are the machine defaults, since they were not specified.</p>
</div> <!-- end section -->

<div class="section" id="app-window">
    <div class="section-title">The Application Window</div>
    <p>If not overriden, the machine starts with a preconfigured window with default dimensions. The command WINDOW is used to override the defaults. The example below will instruct the PTM to open a window with a screen width of 256 pixels and height of 192 pixels. It will also define a "size factor" of 3 which will be used to scale the screen image to fit a larger window. The last parameter indicates that the default tilebuffer will contain 1 layer only (tilebuffers are discussed in their own section further below).</p>
    <div class="code">
    WINDOW 256, 192, 3, 1
    </div>
</div> <!-- end section -->

<div class="section" id="palette">
    <div class="section-title">The Color Palette</div>
    <p>The PTM works with a global color palette with a total of 256 colors. By default, only 2 colors are defined: black (at index 0) and white (at index 1). Palette manipulation can be done via the command PAL. To define colors in the palette, a 24-bit integer value is used to represent the RGB value of the color, usually in hexadecimal notation which makes it easier to identify each component, as seen in the example above, which sets a pure red color at the index 2 of the palette:</p>
    <div class="code">
    PAL 2, &hff0000
    </div>
</div> <!-- end section -->

<div class="section" id="tileset">
    <div class="section-title">The Tileset</div>
    <p>The PTM works with a global tileset with a maximum of 65536 tiles. By default, only 256 tiles are defined. Most of these are blank tiles, but some of them are defined as ASCII characters (in the range of 32 through 126). The tileset contains only pixel pattern information, since colors are defined separately in the global palette. Tileset manipulation can be done via the command CHR. To define tiles in the tileset, a 64-character string is used to represent the pixel pattern. Only the characters '1' and '0' are recognized. '1' represents a pixel which will be rendered using the foreground color, '0' represents a pixel which will be rendered using the background color (or not rendered, depending on the command used to actually draw it). The example below defines a "smiley face" at index 1:</p>
    <div class="code">
    CHR 1, "0011110001000010101001011000000110100101100110010100001000111100"
    </div>
</div> <!-- end section -->

<div class="section" id="tile-register">
    <div class="section-title">The TILE Register</div>
    <p>As a "tile machine", the PTM works mostly with "tiles". Tiles are 8x8 pixel squares that can be used by themselves or to create larger images by "stitching" many tiles together as in a mosaic. As seen in the previous section, the tileset does not contain color information. Colors are assigned to tiles in the TILE register before they are drawn.</p>
    <p>The TILE register is a single, special internal variable that holds a sequence of tile patterns from the tileset along with foreground and background colors. The TILE register contains only indices that reference colors in the global palette and tile patterns in the global tileset. For example, the TILE.NEW command is used to reset the TILE register with new references, as seen below:</p>
    <div class="code">
    TILE.NEW 1, 2, 3
    </div>
    <p>The example above resets the TILE register and assigns to it the tile pattern at index 1 of the tileset, along with the index 2 of the palette for the foreground color, and index 3 of the palette for the background color. Since the TILE register can hold a sequence of tiles, it is possible to add more tiles to it by using the command TILE.ADD, as seen in the example below:</p>
    <div class="code">
    TILE.ADD 2, 2, 3
    TILE.ADD 3, 2, 3
    </div>
    <p>This sequence of tiles can then be implicitly used as input by other commands. For example, they can be drawn on a tilebuffer by using the command PUT. Tilebuffers are discussed in the next section.</p>
    <p>Tiles can also contain arbitrary data, in the form of "properties". Tile properties are simply a collection of name-value pairs, where names must be strings and values can be strings or numbers. You can manipulate tile properties using the commands TILE.SETP and TILE.GETP. Whenever you put or move tiles around in a tilebuffer, their properties go along with them. The example below sets a property "test" with a value of 123 to the tile in the TILE register, and then gets the value from the property "test" into the variable "test_var":</p>
    <div class="code">
    TILE.SETP "test", 123
    TILE.GETP "test", test_var
    </div>

</div> <!-- end section -->

<div class="section" id="tilebuffers">
    <div class="section-title">Tile Buffers</div>
    <p>Everything that appears on the PTM screen that is not a sprite is associated with a tilebuffer. Tilebuffers (also called simply "buffers") are basically containers for tiles. They have a limited capacity, according to their width, height and number of layers. Width and height are measured in tile units, that is, how many tiles fit in each column and row. Buffers are referenced by their id.</p>
    <p>The PTM automatically creates a default buffer at startup. The default buffer has the id "default" and has a specific size that allows it to cover the entire window. The default buffer has only 1 layer, unless this is overriden via the WINDOW command.</p>
    <p>The command BUF.NEW is used to create new buffers. In the example below, a new buffer is created with the id "test", with 2 layers, 20 columns, 10 rows and at the order 1.</p>
    <div class="code">
    BUF.NEW test, 2, 20, 10, 1
    </div>
    <p>Buffer layers are numbered from 0 through the layer count minus 1. That is, if the buffer contains 3 layers, the layers are numbered 0, 1 and 2. Tiles in higher numbered layers appear on top of lower numbered ones.</p>
    <p>Buffers also have an "order" value which indicates the order in which it appears on the screen among other buffers. Buffers with higher order values appear on top of lower order ones.</p>
    <p>Buffers are displayed on the screen through their own built-in viewport. Viewports define a screen rectangle expressed in pixel units, into which the buffer image will be rendered. Viewports also have a X and Y "scroll" register, which indicate the drawing offset in pixel units. The scroll registers are used for smooth scrolling, when the buffer is too large to fit inside the viewport.</p>
    <p>Viewports are defined using the command BUF.VIEW. In the example below, the viewport rectangle for the buffer "test" is defined at the specified x1, y1, x2, y2 coordinates on the screen:</p>
    <div class="code">
    BUF.VIEW test, x1, y1, x2, y2
    </div>
    <p>The viewport scrolling can be performed by changing the X and Y scroll registers via the command BUF.SCRL, as seen in the example below, where the view is scrolled diagonally by 1 pixel in the top-right direction:</p>
    <div class="code">
    BUF.SCRL test, 1, -1
    </div>
    <p>Buffers cannot be destroyed once created, but they can hidden and later shown again as needed. Hiding a buffer does not destroy its contents. The BUF.SHOW and BUF.HIDE commands can be used to show and hide a buffer. Also, the command BUF.TOGL can be used to alternatively show a buffer if it's hidden or hide a buffer if it's shown. The example below shows how to alter the visibility of the "test" buffer:</p>
    <div class="code">
    BUF.HIDE test
    BUF.SHOW test
    BUF.TOGL test
    </div>
    <p>The rendering of tile buffers is internally managed by the PTM. All visible buffers are drawn automatically by the machine on every frame, upon execution of the UPDATE command.</p>
    <p>Another feature of tile buffers is that they have their own background color. The background color appears in every empty position. An empty position is any position in a buffer that does not contain a tile. The rendering of the buffer background color is enabled by default, but it can be disabled. Disabling the buffer background is useful to allow buffers with lower order value to be visible "through" the empty parts. You can use the command BUF.BGOFF to disable background rendering, or BUF.BCOL to enable it and set the specific color (remember that colors are indices into the color palette, not direct RGB values).</p>
    <div class="code">
    BUF.BGOFF test
    BUF.BCOL 1
    </div>
    </div>
</div> <!-- end section -->

</div> <!-- end content -->

</html>